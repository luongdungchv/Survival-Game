// Upgrade NOTE: replaced 'defined FOG_COMBINED_WITH_WORLD_POS' with 'defined (FOG_COMBINED_WITH_WORLD_POS)'

// Made with Amplify Shader Editor
// Available at the Unity Asset Store - http://u3d.as/y3X 
Shader "Raygeas/AZURE Surface"
{
	Properties
	{
		[SingleLineTexture][Header(Maps)][Space(7)]_SurfaceAlbedo("Albedo", 2D) = "white" {}
		[Normal][SingleLineTexture]_SurfaceNormal("Normal", 2D) = "bump" {}
		[SingleLineTexture]_CoverageAlbedo("Coverage Albedo", 2D) = "white" {}
		[Normal][SingleLineTexture]_CoverageNormal("Coverage Normal", 2D) = "bump" {}
		[SingleLineTexture]_CoverageMask("Coverage Mask", 2D) = "white" {}
		[Header(Settings)][Space(5)]_SurfaceColor("Color", Color) = (1,1,1,0)
		_SurfaceSmoothness("Smoothness", Range( 0 , 1)) = 0
		[Header(Show)][Space(5)][Toggle(_SNOW_ON)] _SNOW("Enable", Float) = 0
		_SnowAmount("Amount", Range( 0 , 1)) = 0.5
		_SnowFade("Fade", Range( 0.1 , 1)) = 0.5
		[Header(Coverage)][Space(5)][Toggle(_COVERAGE_ON)] _COVERAGE("Enable", Float) = 0
		_CoverageColor("Color", Color) = (0,0,0,0)
		_CoverageSmoothness("Smoothness", Range( 0 , 1)) = 0
		[KeywordEnum(World_Normal,Vertex_Position)] _CoverageOverlayType("Overlay Method", Float) = 0
		_CoverageLevel("Level", Float) = 0
		_CoverageFade("Fade", Range( -1 , 1)) = 0.5
		_CoverageContrast("Contrast", Range( 0.03 , 1)) = 0.3
		_CoverageThicknessLevel("Thickness", Range( 0 , 1)) = 1
		[Toggle(_BLENDNORMALS_ON)] _BlendNormals("Blend Normals", Float) = 0
		[HideInInspector] _texcoord( "", 2D ) = "white" {}
		[HideInInspector] __dirty( "", Int ) = 1
	}

	SubShader
	{
		Tags{ "RenderType" = "Opaque"  "Queue" = "Geometry+0" }
		Cull Back
		
		// ------------------------------------------------------------
		// Surface shader code generated out of a HLSLPROGRAM block:
		

		// ---- forward rendering base pass:
		Pass {
			Name "FORWARD"
			Tags { "LightMode" = "UniversalForward" }

			HLSLPROGRAM
			// compile directives
			#pragma vertex vert_surf
			#pragma fragment frag_surf
			#pragma target 3.0
			#pragma shader_feature_local _COVERAGE_ON
			#pragma shader_feature_local _BLENDNORMALS_ON
			#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
			#pragma shader_feature_local _SNOW_ON
			#pragma multi_compile_instancing
			#pragma multi_compile __ LOD_FADE_CROSSFADE
			#pragma multi_compile_fog
			#pragma multi_compile_fwdbase
			#include "HLSLSupport.cginc"
			#define UNITY_INSTANCED_LOD_FADE
			#define UNITY_INSTANCED_SH
			#define UNITY_INSTANCED_LIGHTMAPSTS
			#define UNITY_INSTANCED_RENDERER_BOUNDS
			#include "UnityShaderVariables.cginc"
			#include "UnityShaderUtilities.cginc"
			// -------- variant for: _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				CBUFFER_START(UnityPerMaterial)
					uniform sampler2D _SurfaceNormal;
					uniform float4 _SurfaceNormal_ST;
					uniform sampler2D _CoverageNormal;
					uniform float4 _CoverageNormal_ST;
					uniform float _CoverageLevel;
					uniform float _CoverageFade;
					uniform sampler2D _CoverageMask;
					uniform float4 _CoverageMask_ST;
					uniform float _CoverageContrast;
					uniform float _CoverageThicknessLevel;
					uniform float4 _SurfaceColor;
					uniform sampler2D _SurfaceAlbedo;
					uniform float4 _SurfaceAlbedo_ST;
					uniform float4 _CoverageColor;
					uniform sampler2D _CoverageAlbedo;
					uniform float4 _CoverageAlbedo_ST;
					uniform float _SnowAmount;
					uniform float _SnowFade;
					uniform float _SurfaceSmoothness;
					uniform float _CoverageSmoothness;
				CBUFFER_END

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"
				#include "AutoLight.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				// no lightmaps:
				#ifndef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_LIGHTING_COORDS(5,6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							#if UNITY_SHOULD_SAMPLE_SH
								half3 sh : TEXCOORD4; // SH
							#endif
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							#if SHADER_TARGET >= 30
								float4 lmap : TEXCOORD7;
							#endif
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				// with lightmaps:
				#ifdef LIGHTMAP_ON
					// half-precision fragment shader registers:
					#ifdef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						#define FOG_COMBINED_WITH_TSPACE
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_LIGHTING_COORDS(5,6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
					// high-precision fragment shader registers:
					#ifndef UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS
						struct v2f_surf {
							UNITY_POSITION(pos);
							float2 pack0 : TEXCOORD0; // _texcoord
							float4 tSpace0 : TEXCOORD1;
							float4 tSpace1 : TEXCOORD2;
							float4 tSpace2 : TEXCOORD3;
							float4 lmap : TEXCOORD4;
							UNITY_FOG_COORDS(5)
							UNITY_SHADOW_COORDS(6)
							UNITY_VERTEX_INPUT_INSTANCE_ID
							UNITY_VERTEX_OUTPUT_STEREO
						};
					#endif
				#endif
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
					#endif

					// SH/ambient and vertex lights
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							// Approximated illumination from non-important point lights
							#ifdef VERTEXLIGHT_ON
								o.sh += Shade4PointLights (
								unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
								unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
								unity_4LightAtten0, worldPos, worldNormal);
							#endif
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif // !LIGHTMAP_ON

					UNITY_TRANSFER_LIGHTING(o,v.texcoord1.xy); // pass shadow and, possibly, light cookie coordinates to pixel shader
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_TRANSFER_FOG_COMBINED_WITH_TSPACE(o,o.pos); // pass fog coordinates to pixel shader
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_TRANSFER_FOG_COMBINED_WITH_WORLD_POS(o,o.pos); // pass fog coordinates to pixel shader
					#else
						UNITY_TRANSFER_FOG(o,o.pos); // pass fog coordinates to pixel shader
					#endif
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);

					// compute lighting & shadowing factor
					UNITY_LIGHT_ATTENUATION(atten, IN, worldPos)
					fixed4 c = 0;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = _LightColor0.rgb;
					gi.light.dir = lightDir;
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// realtime lighting: call lighting function
					c += LightingStandard (o, worldViewDir, gi);
					UNITY_APPLY_FOG(_unity_fogCoord, c); // apply fog
					return c;
				}


			#endif


			ENDHLSL

		}

		// ---- deferred shading pass:
		Pass {
			Name "DEFERRED"
			Tags { "LightMode" = "Deferred" }

			HLSLPROGRAM
			// compile directives
			#pragma vertex vert_surf
			#pragma fragment frag_surf
			#pragma target 3.0
			#pragma shader_feature_local _COVERAGE_ON
			#pragma shader_feature_local _BLENDNORMALS_ON
			#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
			#pragma shader_feature_local _SNOW_ON
			#pragma multi_compile_instancing
			#pragma multi_compile __ LOD_FADE_CROSSFADE
			#pragma exclude_renderers nomrt
			#pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2
			#pragma multi_compile_prepassfinal
			#include "HLSLSupport.cginc"
			#define UNITY_INSTANCED_LOD_FADE
			#define UNITY_INSTANCED_SH
			#define UNITY_INSTANCED_LIGHTMAPSTS
			#define UNITY_INSTANCED_RENDERER_BOUNDS
			#include "UnityShaderVariables.cginc"
			#include "UnityShaderUtilities.cginc"
			// -------- variant for: _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: YES
				// needs screen space position: no
				// needs world space position: YES
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 1 texcoords actually used
				//   float2 _texcoord
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA half3 internalSurfaceTtoW0; half3 internalSurfaceTtoW1; half3 internalSurfaceTtoW2;
				#define WorldReflectionVector(data,normal) reflect (data.worldRefl, half3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal)))
				#define WorldNormalVector(data,normal) fixed3(dot(data.internalSurfaceTtoW0,normal), dot(data.internalSurfaceTtoW1,normal), dot(data.internalSurfaceTtoW2,normal))

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					UNITY_POSITION(pos);
					float2 pack0 : TEXCOORD0; // _texcoord
					float4 tSpace0 : TEXCOORD1;
					float4 tSpace1 : TEXCOORD2;
					float4 tSpace2 : TEXCOORD3;
					#ifndef DIRLIGHTMAP_OFF
						float3 viewDir : TEXCOORD4;
					#endif
					float4 lmap : TEXCOORD5;
					#ifndef LIGHTMAP_ON
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							half3 sh : TEXCOORD6; // SH
						#endif
					#else
						#ifdef DIRLIGHTMAP_OFF
							float4 lmapFadePos : TEXCOORD6;
						#endif
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};
				float4 _texcoord_ST;

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					o.pos = UnityObjectToClipPos(v.vertex);
					o.pack0.xy = TRANSFORM_TEX(v.texcoord, _texcoord);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					fixed3 worldTangent = UnityObjectToWorldDir(v.tangent.xyz);
					fixed tangentSign = v.tangent.w * unity_WorldTransformParams.w;
					fixed3 worldBinormal = cross(worldNormal, worldTangent) * tangentSign;
					o.tSpace0 = float4(worldTangent.x, worldBinormal.x, worldNormal.x, worldPos.x);
					o.tSpace1 = float4(worldTangent.y, worldBinormal.y, worldNormal.y, worldPos.y);
					o.tSpace2 = float4(worldTangent.z, worldBinormal.z, worldNormal.z, worldPos.z);
					float3 viewDirForLight = UnityWorldSpaceViewDir(worldPos);
					#ifndef DIRLIGHTMAP_OFF
						o.viewDir.x = dot(viewDirForLight, worldTangent);
						o.viewDir.y = dot(viewDirForLight, worldBinormal);
						o.viewDir.z = dot(viewDirForLight, worldNormal);
					#endif
					#ifdef DYNAMICLIGHTMAP_ON
						o.lmap.zw = v.texcoord2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
					#else
						o.lmap.zw = 0;
					#endif
					#ifdef LIGHTMAP_ON
						o.lmap.xy = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
						#ifdef DIRLIGHTMAP_OFF
							o.lmapFadePos.xyz = (mul(unity_ObjectToWorld, v.vertex).xyz - unity_ShadowFadeCenterAndType.xyz) * unity_ShadowFadeCenterAndType.w;
							o.lmapFadePos.w = (-UnityObjectToViewPos(v.vertex).z) * (1.0 - unity_ShadowFadeCenterAndType.w);
						#endif
					#else
						o.lmap.xy = 0;
						#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
							o.sh = 0;
							o.sh = ShadeSHPerVertex (worldNormal, o.sh);
						#endif
					#endif
					return o;
				}
				#ifdef LIGHTMAP_ON
					float4 unity_LightmapFade;
				#endif
				fixed4 unity_Ambient;

				// fragment shader
				void frag_surf (v2f_surf IN,
				out half4 outGBuffer0 : SV_Target0,
				out half4 outGBuffer1 : SV_Target1,
				out half4 outGBuffer2 : SV_Target2,
				out half4 outEmission : SV_Target3
				#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
					, out half4 outShadowMask : SV_Target4
				#endif
				) {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_RECONSTRUCT_TBN(IN);
					#else
						UNITY_EXTRACT_TBN(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					surfIN.uv_texcoord = IN.pack0.xy;
					float3 worldPos = float3(IN.tSpace0.w, IN.tSpace1.w, IN.tSpace2.w);
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					float3 worldViewDir = normalize(UnityWorldSpaceViewDir(worldPos));
					surfIN.worldNormal = 0.0;
					surfIN.internalSurfaceTtoW0 = _unity_tbn_0;
					surfIN.internalSurfaceTtoW1 = _unity_tbn_1;
					surfIN.internalSurfaceTtoW2 = _unity_tbn_2;
					surfIN.worldPos = worldPos;
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);
					o.Normal = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					fixed3 originalNormal = o.Normal;
					float3 worldN;
					worldN.x = dot(_unity_tbn_0, o.Normal);
					worldN.y = dot(_unity_tbn_1, o.Normal);
					worldN.z = dot(_unity_tbn_2, o.Normal);
					worldN = normalize(worldN);
					o.Normal = worldN;
					half atten = 1;

					// Setup lighting environment
					UnityGI gi;
					UNITY_INITIALIZE_OUTPUT(UnityGI, gi);
					gi.indirect.diffuse = 0;
					gi.indirect.specular = 0;
					gi.light.color = 0;
					gi.light.dir = half3(0,1,0);
					// Call GI (lightmaps/SH/reflections) lighting function
					UnityGIInput giInput;
					UNITY_INITIALIZE_OUTPUT(UnityGIInput, giInput);
					giInput.light = gi.light;
					giInput.worldPos = worldPos;
					giInput.worldViewDir = worldViewDir;
					giInput.atten = atten;
					#if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
						giInput.lightmapUV = IN.lmap;
					#else
						giInput.lightmapUV = 0.0;
					#endif
					#if UNITY_SHOULD_SAMPLE_SH && !UNITY_SAMPLE_FULL_SH_PER_PIXEL
						giInput.ambient = IN.sh;
					#else
						giInput.ambient.rgb = 0.0;
					#endif
					giInput.probeHDR[0] = unity_SpecCube0_HDR;
					giInput.probeHDR[1] = unity_SpecCube1_HDR;
					#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION)
						giInput.boxMin[0] = unity_SpecCube0_BoxMin; // .w holds lerp value for blending
					#endif
					#ifdef UNITY_SPECCUBE_BOX_PROJECTION
						giInput.boxMax[0] = unity_SpecCube0_BoxMax;
						giInput.probePosition[0] = unity_SpecCube0_ProbePosition;
						giInput.boxMax[1] = unity_SpecCube1_BoxMax;
						giInput.boxMin[1] = unity_SpecCube1_BoxMin;
						giInput.probePosition[1] = unity_SpecCube1_ProbePosition;
					#endif
					LightingStandard_GI(o, giInput, gi);

					// call lighting function to output g-buffer
					outEmission = LightingStandard_Deferred (o, worldViewDir, gi, outGBuffer0, outGBuffer1, outGBuffer2);
					#if defined(SHADOWS_SHADOWMASK) && (UNITY_ALLOWED_MRT_COUNT > 4)
						outShadowMask = UnityGetRawBakedOcclusions (IN.lmap.xy, worldPos);
					#endif
					#ifndef UNITY_HDR_ON
						outEmission.rgb = exp2(-outEmission.rgb);
					#endif
				}


			#endif


			ENDHLSL

		}

		// ---- shadow caster pass:
		Pass {
			Name "ShadowCaster"
			Tags { "LightMode" = "ShadowCaster" }
			ZWrite On ZTest LEqual

			HLSLPROGRAM
			// compile directives
			#pragma vertex vert_surf
			#pragma fragment frag_surf
			#pragma target 3.0
			#pragma shader_feature_local _COVERAGE_ON
			#pragma shader_feature_local _BLENDNORMALS_ON
			#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
			#pragma shader_feature_local _SNOW_ON
			#pragma multi_compile_instancing
			#pragma multi_compile __ LOD_FADE_CROSSFADE
			#pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2
			#pragma multi_compile_shadowcaster
			#include "HLSLSupport.cginc"
			#define UNITY_INSTANCED_LOD_FADE
			#define UNITY_INSTANCED_SH
			#define UNITY_INSTANCED_LIGHTMAPSTS
			#define UNITY_INSTANCED_RENDERER_BOUNDS
			#include "UnityShaderVariables.cginc"
			#include "UnityShaderUtilities.cginc"
			// -------- variant for: _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(LOD_FADE_CROSSFADE) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(INSTANCING_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGE_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(_BLENDNORMALS_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_WORLD_NORMAL _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && defined(_SNOW_ON) && !defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL) && !defined(_SNOW_ON)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif

			// -------- variant for: LOD_FADE_CROSSFADE INSTANCING_ON _COVERAGE_ON _BLENDNORMALS_ON _COVERAGEOVERLAYTYPE_VERTEX_POSITION _SNOW_ON 
			#if defined(LOD_FADE_CROSSFADE) && defined(INSTANCING_ON) && defined(_COVERAGE_ON) && defined(_BLENDNORMALS_ON) && defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION) && defined(_SNOW_ON) && !defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
				// Surface shader code generated based on:
				// writes to per-pixel normal: YES
				// writes to emission: no
				// writes to occlusion: no
				// needs world space reflection vector: no
				// needs world space normal vector: no
				// needs screen space position: no
				// needs world space position: no
				// needs view direction: no
				// needs world space view direction: no
				// needs world space position for lighting: YES
				// needs world space view direction for lighting: YES
				// needs world space view direction for lightmaps: no
				// needs vertex color: no
				// needs VFACE: no
				// needs SV_IsFrontFace: no
				// passes tangent-to-world matrix to pixel shader: YES
				// reads from normal: no
				// 0 texcoords actually used
				#include "UnityCG.cginc"
				#include "Lighting.cginc"
				#include "UnityPBSLighting.cginc"

				#define INTERNAL_DATA
				#define WorldReflectionVector(data,normal) data.worldRefl
				#define WorldNormalVector(data,normal) normal

				// Original surface shader snippet:
				#line 32 ""
				#ifdef DUMMY_PREPROCESSOR_TO_WORK_AROUND_HLSL_COMPILER_LINE_HANDLING
				#endif
				/* UNITY: Original start of shader */
				#include "UnityStandardUtils.cginc"
				#include "UnityShaderVariables.cginc"
				//#pragma target 3.0
				//#pragma shader_feature_local _COVERAGE_ON
				//#pragma shader_feature_local _BLENDNORMALS_ON
				//#pragma shader_feature_local _COVERAGEOVERLAYTYPE_WORLD_NORMAL _COVERAGEOVERLAYTYPE_VERTEX_POSITION
				//#pragma shader_feature_local _SNOW_ON
				//#pragma surface surf Standard keepalpha addshadow fullforwardshadows nometa noforwardadd dithercrossfade 
				struct Input
				{
					float2 uv_texcoord;
					float3 worldNormal;
					INTERNAL_DATA
					float3 worldPos;
				};

				uniform sampler2D _SurfaceNormal;
				uniform float4 _SurfaceNormal_ST;
				uniform sampler2D _CoverageNormal;
				uniform float4 _CoverageNormal_ST;
				uniform float _CoverageLevel;
				uniform float _CoverageFade;
				uniform sampler2D _CoverageMask;
				uniform float4 _CoverageMask_ST;
				uniform float _CoverageContrast;
				uniform float _CoverageThicknessLevel;
				uniform float4 _SurfaceColor;
				uniform sampler2D _SurfaceAlbedo;
				uniform float4 _SurfaceAlbedo_ST;
				uniform float4 _CoverageColor;
				uniform sampler2D _CoverageAlbedo;
				uniform float4 _CoverageAlbedo_ST;
				uniform float _SnowAmount;
				uniform float _SnowFade;
				uniform float _SurfaceSmoothness;
				uniform float _CoverageSmoothness;

				void surf( Input i , inout SurfaceOutputStandard o )
				{
					float2 uv_SurfaceNormal = i.uv_texcoord * _SurfaceNormal_ST.xy + _SurfaceNormal_ST.zw;
					float3 tex2DNode6 = UnpackNormal( tex2D( _SurfaceNormal, uv_SurfaceNormal ) );
					float2 uv_CoverageNormal = i.uv_texcoord * _CoverageNormal_ST.xy + _CoverageNormal_ST.zw;
					float3 tex2DNode72 = UnpackNormal( tex2D( _CoverageNormal, uv_CoverageNormal ) );
					float3 temp_output_97_0 = BlendNormals( tex2DNode6 , tex2DNode72 );
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch158 = temp_output_97_0;
					#else
						float3 staticSwitch158 = tex2DNode72;
					#endif
					#ifdef _BLENDNORMALS_ON
						float3 staticSwitch160 = temp_output_97_0;
					#else
						float3 staticSwitch160 = tex2DNode72;
					#endif
					float3 ase_worldNormal = WorldNormalVector( i, float3( 0, 0, 1 ) );
					float3 ase_worldPos = i.worldPos;
					float3 temp_output_16_0_g4 = ( ase_worldPos * 100.0 );
					float3 crossY18_g4 = cross( ase_worldNormal , ddy( temp_output_16_0_g4 ) );
					float3 worldDerivativeX2_g4 = ddx( temp_output_16_0_g4 );
					float dotResult6_g4 = dot( crossY18_g4 , worldDerivativeX2_g4 );
					float crossYDotWorldDerivX34_g4 = abs( dotResult6_g4 );
					float3 ase_vertex3Pos = mul( unity_WorldToObject, float4( i.worldPos , 1 ) );
					#if defined(_COVERAGEOVERLAYTYPE_WORLD_NORMAL)
						float staticSwitch164 = ase_worldNormal.y;
					#elif defined(_COVERAGEOVERLAYTYPE_VERTEX_POSITION)
						float staticSwitch164 = ase_vertex3Pos.y;
					#else
						float staticSwitch164 = ase_worldNormal.y;
					#endif
					float2 uv_CoverageMask = i.uv_texcoord * _CoverageMask_ST.xy + _CoverageMask_ST.zw;
					float CoverageMask37 = saturate( ( ( ( ( staticSwitch164 + _CoverageLevel ) * ( _CoverageFade * 5 ) ) + tex2D( _CoverageMask, uv_CoverageMask ).r ) * ( _CoverageContrast * 15 ) ) );
					float temp_output_20_0_g4 = ( CoverageMask37 * ( _CoverageThicknessLevel * 10 ) );
					float3 crossX19_g4 = cross( ase_worldNormal , worldDerivativeX2_g4 );
					float3 break29_g4 = ( sign( crossYDotWorldDerivX34_g4 ) * ( ( ddx( temp_output_20_0_g4 ) * crossY18_g4 ) + ( ddy( temp_output_20_0_g4 ) * crossX19_g4 ) ) );
					float3 appendResult30_g4 = (float3(break29_g4.x , -break29_g4.y , break29_g4.z));
					float3 normalizeResult39_g4 = normalize( ( ( crossYDotWorldDerivX34_g4 * ase_worldNormal ) - appendResult30_g4 ) );
					float3 ase_worldTangent = WorldNormalVector( i, float3( 1, 0, 0 ) );
					float3 ase_worldBitangent = WorldNormalVector( i, float3( 0, 1, 0 ) );
					float3x3 ase_worldToTangent = float3x3( ase_worldTangent, ase_worldBitangent, ase_worldNormal );
					float3 worldToTangentDir42_g4 = mul( ase_worldToTangent, normalizeResult39_g4);
					float3 lerpResult73 = lerp( tex2DNode6 , ( staticSwitch158 + BlendNormals( staticSwitch160 , worldToTangentDir42_g4 ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float3 staticSwitch156 = lerpResult73;
					#else
						float3 staticSwitch156 = tex2DNode6;
					#endif
					float3 Normal75 = staticSwitch156;
					o.Normal = Normal75;
					float2 uv_SurfaceAlbedo = i.uv_texcoord * _SurfaceAlbedo_ST.xy + _SurfaceAlbedo_ST.zw;
					float4 temp_output_3_0 = ( _SurfaceColor * tex2D( _SurfaceAlbedo, uv_SurfaceAlbedo ) );
					float2 uv_CoverageAlbedo = i.uv_texcoord * _CoverageAlbedo_ST.xy + _CoverageAlbedo_ST.zw;
					float4 lerpResult26 = lerp( temp_output_3_0 , ( _CoverageColor * tex2D( _CoverageAlbedo, uv_CoverageAlbedo ) ) , CoverageMask37);
					#ifdef _COVERAGE_ON
						float4 staticSwitch136 = lerpResult26;
					#else
						float4 staticSwitch136 = temp_output_3_0;
					#endif
					float4 color138 = IsGammaSpace() ? float4(0.9,0.9,0.9,0) : float4(0.7874123,0.7874123,0.7874123,0);
					float temp_output_144_0 = ( _SnowAmount * 3 );
					float saferPower148 = max( saturate( ( (WorldNormalVector( i , Normal75 )).y * temp_output_144_0 ) ) , 0.0001 );
					float SnowMask149 = pow( saferPower148 , ( _SnowFade * 10 ) );
					float4 lerpResult154 = lerp( staticSwitch136 , color138 , SnowMask149);
					#ifdef _SNOW_ON
						float4 staticSwitch155 = lerpResult154;
					#else
						float4 staticSwitch155 = staticSwitch136;
					#endif
					float4 Albedo19 = staticSwitch155;
					o.Albedo = Albedo19.rgb;
					float lerpResult70 = lerp( _SurfaceSmoothness , _CoverageSmoothness , CoverageMask37);
					#ifdef _COVERAGE_ON
						float staticSwitch157 = lerpResult70;
					#else
						float staticSwitch157 = _SurfaceSmoothness;
					#endif
					float Smoothness76 = staticSwitch157;
					o.Smoothness = Smoothness76;
					o.Alpha = 1;
				}

				

				// vertex-to-fragment interpolation data
				struct v2f_surf {
					V2F_SHADOW_CASTER;
					float3 worldPos : TEXCOORD1;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
				};

				// vertex shader
				v2f_surf vert_surf (appdata_full v) {
					UNITY_SETUP_INSTANCE_ID(v);
					v2f_surf o;
					UNITY_INITIALIZE_OUTPUT(v2f_surf,o);
					UNITY_TRANSFER_INSTANCE_ID(v,o);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					float3 worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
					float3 worldNormal = UnityObjectToWorldNormal(v.normal);
					o.worldPos.xyz = worldPos;
					TRANSFER_SHADOW_CASTER_NORMALOFFSET(o)
					return o;
				}

				// fragment shader
				fixed4 frag_surf (v2f_surf IN) : SV_Target {
					UNITY_SETUP_INSTANCE_ID(IN);
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(IN);
					// prepare and unpack data
					Input surfIN;
					#ifdef FOG_COMBINED_WITH_TSPACE
						UNITY_EXTRACT_FOG_FROM_TSPACE(IN);
					#elif defined (FOG_COMBINED_WITH_WORLD_POS)
						UNITY_EXTRACT_FOG_FROM_WORLD_POS(IN);
					#else
						UNITY_EXTRACT_FOG(IN);
					#endif
					UNITY_INITIALIZE_OUTPUT(Input,surfIN);
					surfIN.uv_texcoord.x = 1.0;
					surfIN.worldNormal.x = 1.0;
					surfIN.worldPos.x = 1.0;
					float3 worldPos = IN.worldPos.xyz;
					#ifndef USING_DIRECTIONAL_LIGHT
						fixed3 lightDir = normalize(UnityWorldSpaceLightDir(worldPos));
					#else
						fixed3 lightDir = _WorldSpaceLightPos0.xyz;
					#endif
					#ifdef UNITY_COMPILER_HLSL
						SurfaceOutputStandard o = (SurfaceOutputStandard)0;
					#else
						SurfaceOutputStandard o;
					#endif
					o.Albedo = 0.0;
					o.Emission = 0.0;
					o.Alpha = 0.0;
					o.Occlusion = 1.0;
					fixed3 normalWorldVertex = fixed3(0,0,1);

					// call surface function
					surf (surfIN, o);
					UNITY_APPLY_DITHER_CROSSFADE(IN.pos.xy);
					SHADOW_CASTER_FRAGMENT(IN)
				}


			#endif


			ENDHLSL

		}

		// ---- end of surface shader generated code

		#LINE 155

	}
	Fallback "Diffuse"
}
